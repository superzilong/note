# 算法

## Roadmap

![roadmap](https://pic1.zhimg.com/80/v2-f221b3de2a863b53ef0cb75fec879d72_720w.jpg)
这张图包含10个数据结构：数组、链表、栈、队列、散列表、二叉树、堆、跳表、图、Trie 树；10个算法：递归、排序、二分查找、搜索、哈希算法、贪心算法、分治算法、回溯算法、动态规划、字符串匹配算法。

## 算法可视化

<https://www.cs.usfca.edu/~galles/visualization/Algorithms.html>

<https://algorithm-visualizer.org/>

## 排序算法

`NOTE:` 以一个长度有限的随机整数列，从小到大进行排序来讲解.

* **选择排序(select sort):** 遍历所有整数, 找到最小数, 与第一个整数互换, 再从第二个数开始找到最小数, 与第二个数互换, 依此类推, 直到结束.

* **插入排序(insert sort):** 类似打扑克牌时取完牌后整理牌的过程, 从数组第一个整数开始, 将数字插入到比自己小和比自己大的数字中间, 直到结束.

* **冒泡排序(bubble sort):** 从第一个数开始, 与右边相邻的数进行比较, 如果比相邻的数大, 则进行互换.

* **归并排序(merge sort):** 使用递归思想, 将数组不断二等分切割, 到切割不能再切割时再进行合并, 合并时要按照从小到大的顺序.

* **快速排序(quick sort):** 选择一个数,将小于这个数的数字排到左边,大于这个数的数字排到右边,然后分别从左边和右边的数字中选择一个数字重复这样的操作.

* **堆排序(heap sort):**

* **桶排序(bucket sort):**

## 查找算法

* 二分查找的复杂度为: O(logN)
* 散列表查找的复杂度为: O(1)

## 贪心算法

用来解决NP完全问题时, 找到近似最优解, 讲问题分成n个步骤, 每个步骤作出最有利的选择. 例如背包问题, 每步都塞进最有利的物品.

## 动态规划

利用画网格的方式, 讲问题分解成n个小问题, 然后将从1到n逐步解决, 当解决第j个问题时, 需要参考j-1个问题的最优解

## Brute Force

穷举法

## Sliding Window

通过移动一个window两边的边界, 来寻求最长的长度. 例如用来解决最长子字符串问题.

## 图

有向图, 无向图, 加权图.

### 计算最小路径

* 广度优先算法计算普通图的最小路径
* 迪杰斯特拉算法(Dijkstra)来计算加权图的路径
* 贝尔曼福德算法(Bellman-Ford)来计算加权图中的权带有负数的情况

## 参考内容

<https://www.zhihu.com/question/20588261/answer/926157817>